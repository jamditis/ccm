<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NJ PBS Visual Editor</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts: Space Grotesk -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- React Framework -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Export Tool -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --bg-dark: #020617;
            --accent-blue: #3b82f6;
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: var(--bg-dark); 
            font-family: 'Space Grotesk', sans-serif;
            color: #e2e8f0;
            user-select: none;
        }

        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #0f172a; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #475569; }

        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .modal-animate { animation: fadeIn 0.2s ease-out forwards; }
        
        @keyframes pulse-ring { 0% { transform: scale(0.8); opacity: 0.5; } 100% { transform: scale(2); opacity: 0; } }
        .pulse-dot::before { content: ''; position: absolute; left: 0; top: 0; width: 100%; height: 100%; background-color: inherit; border-radius: 50%; animation: pulse-ring 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) infinite; z-index: -1; }

        .glass-panel { background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(51, 65, 85, 0.5); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // --- ICONS ---
        const Icons = {
            Users: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>,
            Scale: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z"/><path d="m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z"/><path d="M7 21h10"/><path d="M12 3v18"/><path d="M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2"/></svg>,
            Building2: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z"/><path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2"/><path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2"/><path d="M10 6h4"/><path d="M10 10h4"/><path d="M10 14h4"/><path d="M10 18h4"/></svg>,
            Radio: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4.9 19.1C1 15.2 1 8.8 4.9 4.9"/><path d="M7.8 16.2c-2.3-2.3-2.3-6.1 0-8.5"/><circle cx="12" cy="12" r="2"/><path d="M16.2 7.8c2.3 2.3 2.3 6.1 0 8.5"/><path d="M19.1 4.9C23 8.8 23 15.1 19.1 19"/></svg>,
            GraduationCap: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 10v6M2 10l10-5 10 5-10 5z"/><path d="M6 12v5c3 3 9 3 12 0v-5"/></svg>,
            ShieldCheck: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/><path d="m9 12 2 2 4-4"/></svg>,
            Layout: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="3" x2="21" y1="9" y2="9"/><line x1="9" x2="9" y1="9" y2="21"/></svg>,
            Globe: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="2" x2="22" y1="12" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1 4-10z"/></svg>,
            Mic2: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12 8-9.04 9.06a2.82 2.82 0 1 0 3.98 3.98L16 12"/><path d="m19 7-7 7"/><path d="M15 6v-1a2 2 0 1 1 4 0v2"/><path d="M21 5v2"/><path d="M21 11v2"/></svg>,
            Tv: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="15" x="2" y="7" rx="2" ry="2"/><polyline points="17 2 12 7 7 2"/></svg>,
            DollarSign: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" x2="12" y1="2" y2="22"/><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"/></svg>,
            Settings: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
            Briefcase: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="14" x="2" y="7" rx="2" ry="2"/><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"/></svg>,
            Camera: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>,
            Move: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/></svg>,
            MousePointer2: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12 19-2.96-7.05L2 9l22-7-7 22-2.95-7.04Z"/></svg>,
            Lock: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>,
            Unlock: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>,
            Maximize: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/></svg>,
            Minimize: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/></svg>,
            RefreshCw: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>,
            Sparkles: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275Z"/></svg>,
            HelpCircle: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>,
            X: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="m6 6 18 18"/></svg>,
            Target: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
            Plus: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" x2="12" y1="5" y2="19"/><line x1="5" x2="19" y1="12" y2="12"/></svg>,
            Trash2: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>,
            Link: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>,
            Edit: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>,
            Sun: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>,
            Moon: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>,
            Palette: (p) => <svg {...p} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></svg>
        };

        const THEMES = {
            dark: {
                name: 'Dark',
                bg: '#020617',
                canvas: '#0f172a',
                text: '#e2e8f0',
                textSecondary: '#94a3b8',
                border: '#334155',
                panel: 'rgba(15, 23, 42, 0.85)',
                nodes: {
                    default: "bg-slate-800/90 border-slate-600 text-slate-200 shadow-lg",
                    primary: "bg-blue-900/60 border-blue-400/50 text-blue-50 shadow-[0_0_20px_rgba(59,130,246,0.2)] backdrop-blur-md",
                    secondary: "bg-purple-900/60 border-purple-400/50 text-purple-50 shadow-[0_0_20px_rgba(168,85,247,0.2)] backdrop-blur-md",
                    tertiary: "bg-emerald-900/60 border-emerald-400/50 text-emerald-50 shadow-lg backdrop-blur-md",
                    warning: "bg-amber-900/60 border-amber-400/50 text-amber-50 shadow-lg backdrop-blur-md",
                    danger: "bg-rose-900/60 border-rose-400/50 text-rose-50 shadow-lg backdrop-blur-md",
                    ghost: "bg-slate-900/30 border-dashed border-slate-500/50 text-slate-400"
                },
                gridOpacity: 0.2,
                gridColor: '#334155',
                edgeColor: '#475569',
                edgeColorHover: '#60a5fa'
            },
            light: {
                name: 'Light',
                bg: '#ffffff',
                canvas: '#f8fafc',
                text: '#0f172a',
                textSecondary: '#475569',
                border: '#cbd5e1',
                panel: 'rgba(248, 250, 252, 0.95)',
                nodes: {
                    default: "bg-white border-slate-300 text-slate-800 shadow-lg",
                    primary: "bg-blue-50 border-blue-400 text-blue-900 shadow-[0_0_15px_rgba(59,130,246,0.15)]",
                    secondary: "bg-purple-50 border-purple-400 text-purple-900 shadow-[0_0_15px_rgba(168,85,247,0.15)]",
                    tertiary: "bg-emerald-50 border-emerald-400 text-emerald-900 shadow-lg",
                    warning: "bg-amber-50 border-amber-400 text-amber-900 shadow-lg",
                    danger: "bg-rose-50 border-rose-400 text-rose-900 shadow-lg",
                    ghost: "bg-slate-50/50 border-dashed border-slate-300 text-slate-600"
                },
                gridOpacity: 0.15,
                gridColor: '#cbd5e1',
                edgeColor: '#94a3b8',
                edgeColorHover: '#3b82f6'
            },
            blueprint: {
                name: 'Blueprint',
                bg: '#0a1929',
                canvas: '#0d2847',
                text: '#90caf9',
                textSecondary: '#64b5f6',
                border: '#1e4976',
                panel: 'rgba(13, 40, 71, 0.9)',
                nodes: {
                    default: "bg-blue-950/80 border-blue-400/70 text-blue-100 shadow-[0_0_20px_rgba(33,150,243,0.3)]",
                    primary: "bg-cyan-900/70 border-cyan-300/80 text-cyan-50 shadow-[0_0_25px_rgba(0,188,212,0.4)] backdrop-blur-sm",
                    secondary: "bg-blue-900/70 border-blue-300/80 text-blue-50 shadow-[0_0_25px_rgba(33,150,243,0.4)] backdrop-blur-sm",
                    tertiary: "bg-teal-900/70 border-teal-300/80 text-teal-50 shadow-[0_0_20px_rgba(0,150,136,0.3)]",
                    warning: "bg-amber-900/70 border-amber-300/80 text-amber-50 shadow-[0_0_20px_rgba(255,193,7,0.3)]",
                    danger: "bg-red-900/70 border-red-300/80 text-red-50 shadow-[0_0_20px_rgba(244,67,54,0.3)]",
                    ghost: "bg-blue-950/30 border-dashed border-blue-400/40 text-blue-300"
                },
                gridOpacity: 0.25,
                gridColor: '#1e4976',
                edgeColor: '#42a5f5',
                edgeColorHover: '#90caf9'
            }
        };

        const NODE_STYLES = THEMES.dark.nodes; // Default for backwards compatibility

        // --- INITIAL DATA ---

        /**
         * Generates a unique identifier string for nodes and edges.
         *
         * Uses a random base-36 string (0-9, a-z) to create compact,
         * collision-resistant IDs. The format is 'id_' followed by
         * 9 alphanumeric characters.
         *
         * Note: This is NOT cryptographically secure. It's suitable for
         * UI element identification but not for security-sensitive uses.
         *
         * @returns {string} A unique identifier in format 'id_xxxxxxxxx'
         *
         * @example
         * const nodeId = generateId();
         * // Returns something like: 'id_kj4m9xq2r'
         */
        const generateId = () => 'id_' + Math.random().toString(36).substr(2, 9);
        
        const INITIAL_DATA_SETS = {
            '1.1': {
                layout: 'flow',
                nodes: [
                    { id: 'n1', x: 100, y: 150, type: 'primary', label: 'NJPBA', sub: 'License Holder', icon: 'Radio' },
                    { id: 'n2', x: 600, y: 150, type: 'secondary', label: 'Montclair State', sub: 'Programming Provider', icon: 'Building2' },
                    { id: 'n3', x: 350, y: 150, type: 'default', label: 'PSA Agreement', sub: 'Contract', icon: 'Scale' },
                    { id: 'n4', x: 350, y: 350, type: 'tertiary', label: 'Advisory Board', sub: 'Community Input', icon: 'Users' },
                    { id: 'n5', x: 600, y: 300, type: 'ghost', label: 'School of Comm.', sub: 'Integration', icon: 'Layout' },
                    { id: 'n6', x: 600, y: 400, type: 'ghost', label: 'Center for Coop Media', sub: 'Integration', icon: 'Globe' }
                ],
                edges: [
                    { id: 'e1', source: 'n1', target: 'n3', label: 'Delegates Ops' },
                    { id: 'e2', source: 'n3', target: 'n2', label: 'Provides Services' },
                    { id: 'e3', source: 'n3', target: 'n4', label: 'Oversight' },
                    { id: 'e4', source: 'n2', target: 'n5', label: 'Resources' },
                    { id: 'e5', source: 'n2', target: 'n6', label: 'Partnership' }
                ]
            },
            '1.2': {
                layout: 'tree',
                nodes: [
                    { id: 'root', x: 400, y: 50, type: 'primary', label: 'NJPBA Board', sub: 'License Holder', icon: 'Radio', level: 0 },
                    { id: 'pres', x: 400, y: 150, type: 'secondary', label: 'MSU President', sub: 'University Lead', icon: 'Building2', level: 1 },
                    { id: 'prov', x: 400, y: 250, type: 'default', label: 'Provost', sub: 'Academic Lead', icon: 'GraduationCap', level: 2 },
                    { id: 'dean', x: 400, y: 350, type: 'default', label: 'Dean', sub: 'College of Comm.', icon: 'Briefcase', level: 3 },
                    { id: 'gm', x: 400, y: 450, type: 'primary', label: 'General Manager', sub: 'NJ PBS', icon: 'Tv', level: 4 },
                    
                    { id: 'prog', x: 100, y: 600, type: 'tertiary', label: 'Programming', icon: 'Layout', level: 5 },
                    { id: 'tech', x: 250, y: 600, type: 'warning', label: 'Technology', icon: 'Settings', level: 5 },
                    { id: 'news', x: 400, y: 600, type: 'danger', label: 'News / Editorial', icon: 'Mic2', level: 5 },
                    { id: 'rev', x: 550, y: 600, type: 'tertiary', label: 'Revenue', icon: 'DollarSign', level: 5 },
                    { id: 'ops', x: 700, y: 600, type: 'default', label: 'Admin', icon: 'Briefcase', level: 5 },

                    { id: 'sub1', x: 100, y: 700, type: 'ghost', label: 'Audience / Partners', level: 6, parent: 'prog' },
                    { id: 'sub2', x: 400, y: 700, type: 'ghost', label: 'Producers', level: 6, parent: 'news' },
                    { id: 'sub3', x: 550, y: 700, type: 'ghost', label: 'Membership', level: 6, parent: 'rev' }
                ],
                edges: [
                    { id: 'e1', source: 'root', target: 'pres', dashed: true, label: 'PSA' },
                    { id: 'e2', source: 'pres', target: 'prov' },
                    { id: 'e3', source: 'prov', target: 'dean' },
                    { id: 'e4', source: 'dean', target: 'gm' },
                    { id: 'e5', source: 'gm', target: 'prog' },
                    { id: 'e6', source: 'gm', target: 'tech' },
                    { id: 'e7', source: 'gm', target: 'news' },
                    { id: 'e8', source: 'gm', target: 'rev' },
                    { id: 'e9', source: 'gm', target: 'ops' },
                    { id: 'e10', source: 'prog', target: 'sub1' },
                    { id: 'e11', source: 'news', target: 'sub2' },
                    { id: 'e12', source: 'rev', target: 'sub3' }
                ]
            },
            '1.3': {
                layout: 'columns',
                nodes: [
                    { id: 'comm', x: 150, y: 100, type: 'tertiary', label: 'Community Board', sub: 'Advisory', icon: 'Users', width: 250, col: 0 },
                    { id: 'c_det1', x: 150, y: 220, type: 'ghost', label: 'North / Central / South Reps', width: 200, col: 0 },
                    { id: 'c_det2', x: 150, y: 300, type: 'ghost', label: 'Quarterly Meetings', width: 200, col: 0 },

                    { id: 'edit', x: 450, y: 100, type: 'danger', label: 'Editorial Independence', sub: 'Oversight', icon: 'ShieldCheck', width: 250, col: 1 },
                    { id: 'e_det1', x: 450, y: 220, type: 'ghost', label: 'Firewall Enforcement', width: 200, col: 1 },
                    { id: 'e_det2', x: 450, y: 300, type: 'ghost', label: 'Journalists & Academics', width: 200, col: 1 },

                    { id: 'stu', x: 750, y: 100, type: 'secondary', label: 'Student Board', sub: 'Educational', icon: 'GraduationCap', width: 250, col: 2 },
                    { id: 's_det1', x: 750, y: 220, type: 'ghost', label: 'Faculty Advisors', width: 200, col: 2 },
                    { id: 's_det2', x: 750, y: 300, type: 'ghost', label: 'Curriculum Integration', width: 200, col: 2 },
                ],
                edges: [
                    { id: 'e1', source: 'comm', target: 'c_det1' },
                    { id: 'e2', source: 'c_det1', target: 'c_det2' },
                    { id: 'e3', source: 'edit', target: 'e_det1' },
                    { id: 'e4', source: 'e_det1', target: 'e_det2' },
                    { id: 'e5', source: 'stu', target: 's_det1' },
                    { id: 'e6', source: 's_det1', target: 's_det2' }
                ]
            }
        };

        /**
         * LayoutEngine - Automatic Graph Layout Algorithm
         *
         * This module implements a layered graph drawing algorithm based on the
         * Sugiyama framework (also known as hierarchical layout). The algorithm
         * produces clean, readable layouts for directed graphs by:
         *
         * 1. Layer Assignment: Assigns nodes to horizontal layers using BFS
         * 2. Crossing Reduction: Minimizes edge crossings using the barycenter heuristic
         * 3. Position Assignment: Places nodes with even spacing within each layer
         * 4. Force-Directed Refinement: Fine-tunes positions for aesthetic alignment
         *
         * @see Sugiyama, K., Tagawa, S., & Toda, M. (1981). "Methods for Visual
         *      Understanding of Hierarchical System Structures"
         *
         * @namespace LayoutEngine
         */
        const LayoutEngine = {
            /**
             * Calculates the display dimensions for a node based on its content.
             *
             * The width is dynamically computed based on the label text length,
             * with constraints to prevent nodes from being too narrow or too wide.
             *
             * @param {Object} node - The node object to measure
             * @param {string} [node.label] - The text label displayed in the node
             * @param {number} [node.width=180] - Explicit width override
             * @param {number} [node.height=80] - Explicit height override
             * @returns {{width: number, height: number}} The calculated dimensions
             *
             * @example
             * const dims = LayoutEngine.getNodeDimensions({ label: "Hello World" });
             * // Returns: { width: 180, height: 80 }
             */
            getNodeDimensions: (node) => {
                const baseWidth = node.width || 180;
                const baseHeight = node.height || 80;
                // Estimate width based on label length (8px per character + padding)
                const labelWidth = (node.label?.length || 0) * 8 + 60;
                // Clamp width between baseWidth and 300px maximum
                const width = Math.max(baseWidth, Math.min(labelWidth, 300));
                return { width, height: baseHeight };
            },

            /**
             * Builds an adjacency list representation of the graph from nodes and edges.
             *
             * Creates a Map where each node is augmented with:
             * - inEdges: Array of node IDs that point TO this node
             * - outEdges: Array of node IDs that this node points TO
             *
             * This structure enables efficient traversal for layer assignment
             * and crossing reduction algorithms.
             *
             * @param {Array<Object>} nodes - Array of node objects with 'id' property
             * @param {Array<Object>} edges - Array of edge objects with 'source' and 'target' properties
             * @returns {Map<string, Object>} Map from node ID to augmented node object
             *
             * @example
             * const nodes = [{ id: 'a' }, { id: 'b' }];
             * const edges = [{ source: 'a', target: 'b' }];
             * const graph = LayoutEngine.buildGraphStructure(nodes, edges);
             * // graph.get('a').outEdges = ['b']
             * // graph.get('b').inEdges = ['a']
             */
            buildGraphStructure: (nodes, edges) => {
                // Initialize each node with empty adjacency lists
                const nodeMap = new Map(nodes.map(n => [n.id, { ...n, inEdges: [], outEdges: [] }]));

                // Populate adjacency lists from edges
                edges.forEach(edge => {
                    const source = nodeMap.get(edge.source);
                    const target = nodeMap.get(edge.target);
                    if (source && target) {
                        source.outEdges.push(edge.target);
                        target.inEdges.push(edge.source);
                    }
                });

                return nodeMap;
            },

            /**
             * Assigns nodes to horizontal layers using a modified BFS traversal.
             *
             * This implements the "longest path" layer assignment strategy:
             * - Root nodes (no incoming edges) are placed at layer 0
             * - Each node is placed at max(parent_layer) + 1
             * - This ensures edges always point downward (from lower to higher layers)
             *
             * Special handling:
             * - If no root nodes exist (cyclic graph), uses nodes with fewest incoming edges
             * - Disconnected nodes are placed at layer 0
             *
             * Time Complexity: O(V + E) where V = nodes, E = edges
             *
             * @param {Map<string, Object>} nodeMap - Graph structure from buildGraphStructure()
             * @returns {Map<string, number>} Map from node ID to layer index (0-based)
             *
             * @example
             * // For a simple chain: A -> B -> C
             * // Returns: Map { 'A' => 0, 'B' => 1, 'C' => 2 }
             */
            assignLayers: (nodeMap) => {
                const layers = new Map();
                const visited = new Set();

                // Find root nodes (no incoming edges) - these start at layer 0
                const roots = Array.from(nodeMap.values()).filter(n => n.inEdges.length === 0);

                // Handle cyclic graphs: if no roots, use nodes with fewest incoming edges
                if (roots.length === 0) {
                    const minInEdges = Math.min(...Array.from(nodeMap.values()).map(n => n.inEdges.length));
                    roots.push(...Array.from(nodeMap.values()).filter(n => n.inEdges.length === minInEdges));
                }

                // BFS traversal to assign layers
                // Each node gets max(parent_layer) + 1 to ensure proper hierarchy
                const queue = roots.map(n => ({ node: n, layer: 0 }));

                while (queue.length > 0) {
                    const { node, layer } = queue.shift();

                    // Update layer only if new layer is deeper (handles multiple parents)
                    if (!layers.has(node.id) || layers.get(node.id) < layer) {
                        layers.set(node.id, layer);
                    }

                    // Enqueue all children to be placed one layer below
                    node.outEdges.forEach(childId => {
                        const child = nodeMap.get(childId);
                        if (child) {
                            queue.push({ node: child, layer: layer + 1 });
                        }
                    });
                }

                // Handle disconnected nodes by placing them at layer 0
                nodeMap.forEach((node, id) => {
                    if (!layers.has(id)) {
                        layers.set(id, 0);
                    }
                });

                return layers;
            },

            /**
             * Reduces edge crossings using the barycenter heuristic.
             *
             * The barycenter method is a popular crossing reduction algorithm that:
             * 1. For each node in a layer, calculates the average position (barycenter)
             *    of its connected nodes in the adjacent layer
             * 2. Reorders nodes within the layer by their barycenter values
             * 3. Repeats for multiple passes to improve the result
             *
             * The algorithm makes 3 passes (top-down) for better convergence.
             *
             * Mathematical definition:
             *   barycenter(v) = (1/|N(v)|) * Σ position(u) for all u ∈ N(v)
             *   where N(v) is the set of neighbors in the adjacent layer
             *
             * Time Complexity: O(passes * layers * nodes)
             *
             * @param {Array<Array<Object>>} layerGroups - 2D array where layerGroups[i]
             *        contains nodes at layer i
             * @param {Map<string, Object>} nodeMap - Graph structure with adjacency info
             * @returns {Array<Array<Object>>} The reordered layer groups (mutated in place)
             *
             * @see Eades, P., & Wormald, N. (1994). "Edge crossings in drawings of
             *      bipartite graphs"
             */
            reduceCrossings: (layerGroups, nodeMap) => {
                // Multiple passes for better results (3 passes is a common heuristic)
                for (let pass = 0; pass < 3; pass++) {
                    layerGroups.forEach((layer, layerIdx) => {
                        // Skip first layer (no previous layer to reference)
                        if (layerIdx === 0) return;

                        // Calculate barycenter for each node based on connected nodes in previous layer
                        layer.forEach(node => {
                            // Find positions of all connected nodes in the previous layer
                            const connectedInPrevLayer = node.inEdges
                                .map(sourceId => {
                                    const sourceNode = nodeMap.get(sourceId);
                                    // Get the index (position) of the source node in the previous layer
                                    return layerGroups[layerIdx - 1]?.indexOf(sourceNode);
                                })
                                .filter(idx => idx !== undefined && idx !== -1);

                            // Barycenter = average position of connected nodes
                            if (connectedInPrevLayer.length > 0) {
                                node._barycenter = connectedInPrevLayer.reduce((a, b) => a + b, 0) / connectedInPrevLayer.length;
                            } else {
                                // If no connections to previous layer, keep current position
                                node._barycenter = layer.indexOf(node);
                            }
                        });

                        // Sort nodes within this layer by their barycenter values
                        layer.sort((a, b) => (a._barycenter || 0) - (b._barycenter || 0));
                    });
                }

                return layerGroups;
            },

            /**
             * Main orchestration function that automatically arranges all nodes.
             *
             * This is the primary entry point for the layout algorithm. It coordinates
             * the complete Sugiyama-style layout process:
             *
             * 1. Build graph structure (adjacency lists)
             * 2. Assign nodes to layers (vertical positioning)
             * 3. Reduce edge crossings (horizontal ordering within layers)
             * 4. Calculate final positions (pixel coordinates)
             * 5. Apply force-directed refinements (aesthetic improvements)
             *
             * The algorithm produces layouts where:
             * - Edges generally flow top-to-bottom (or left-to-right)
             * - Edge crossings are minimized
             * - Nodes are evenly spaced within their layers
             * - Connected nodes are horizontally aligned when possible
             *
             * @param {string} tab - Tab identifier (for debugging/logging purposes)
             * @param {Array<Object>} nodes - Array of node objects with id, x, y properties
             * @param {Array<Object>} edges - Array of edge objects with source, target properties
             * @param {number} [containerWidth=1200] - Width of the container for centering
             * @returns {Array<Object>} New array of nodes with updated x, y, width, height properties
             *
             * @example
             * const arranged = LayoutEngine.autoArrange('main', nodes, edges, 1000);
             * // Returns nodes with updated positions for a clean layout
             */
            autoArrange: (tab, nodes, edges, containerWidth) => {
                if (nodes.length === 0) return nodes;

                // Create deep copy to avoid mutating original nodes
                const newNodes = JSON.parse(JSON.stringify(nodes));
                const width = containerWidth || 1200;

                // Step 1: Build graph structure (adjacency lists for efficient traversal)
                const nodeMap = LayoutEngine.buildGraphStructure(newNodes, edges);

                // Step 2: Assign layers based on graph structure (vertical positioning)
                const layers = LayoutEngine.assignLayers(nodeMap);

                // Step 3: Group nodes by their assigned layer
                const maxLayer = Math.max(...layers.values());
                const layerGroups = Array.from({ length: maxLayer + 1 }, () => []);

                nodeMap.forEach((node, id) => {
                    const layer = layers.get(id);
                    layerGroups[layer].push(node);
                });

                // Step 4: Reduce edge crossings via barycenter ordering
                LayoutEngine.reduceCrossings(layerGroups, nodeMap);

                // Step 5: Calculate final pixel positions
                const verticalSpacing = 150;   // Pixels between layers
                const horizontalSpacing = 50;  // Pixels between nodes in same layer
                const paddingTop = 100;        // Top margin
                const paddingLeft = 100;       // Minimum left margin

                // Position nodes layer by layer
                layerGroups.forEach((layer, layerIdx) => {
                    if (layer.length === 0) return;

                    // Calculate total width needed for this layer
                    const layerWidths = layer.map(n => LayoutEngine.getNodeDimensions(n).width);
                    const totalLayerWidth = layerWidths.reduce((a, b) => a + b, 0) + (horizontalSpacing * (layer.length - 1));

                    // Center the layer horizontally within the container
                    let currentX = Math.max(paddingLeft, (width - totalLayerWidth) / 2);
                    const currentY = paddingTop + (layerIdx * verticalSpacing);

                    // Position each node in the layer
                    layer.forEach((node, nodeIdx) => {
                        const dims = LayoutEngine.getNodeDimensions(node);
                        node.x = currentX;
                        node.y = currentY;
                        node.width = dims.width;
                        node.height = dims.height;

                        currentX += dims.width + horizontalSpacing;
                    });
                });

                // Step 6: Apply force-directed adjustments for better edge alignment
                LayoutEngine.applyForceDirectedAdjustments(layerGroups, nodeMap, edges);

                return Array.from(nodeMap.values());
            },

            /**
             * Applies gentle force-directed adjustments to improve edge aesthetics.
             *
             * After the main Sugiyama layout, this function performs minor horizontal
             * adjustments to reduce the visual length/angle of edges. It uses a
             * simplified force-directed approach where:
             *
             * - Each node is attracted toward the X position of its connected nodes
             * - Forces are averaged to prevent oscillation
             * - Multiple iterations allow the layout to settle
             *
             * The force calculation:
             *   forceX = Σ (connected_node.x - this_node.x) * strength
             *   new_x = old_x + forceX / num_connections
             *
             * This helps align nodes that are connected, creating straighter
             * (more vertical) edges which are easier to read.
             *
             * Note: This only adjusts X positions. Y positions are fixed by layer
             * assignment to maintain the hierarchical structure.
             *
             * @param {Array<Array<Object>>} layerGroups - 2D array of nodes by layer
             * @param {Map<string, Object>} nodeMap - Graph structure with adjacency info
             * @param {Array<Object>} edges - Edge array (unused but kept for API consistency)
             *
             * @private
             */
            applyForceDirectedAdjustments: (layerGroups, nodeMap, edges) => {
                const iterations = 5;       // Number of refinement passes
                const forceStrength = 0.3;  // How strongly to apply the force (0-1)

                for (let iter = 0; iter < iterations; iter++) {
                    layerGroups.forEach((layer, layerIdx) => {
                        layer.forEach(node => {
                            let forceX = 0;

                            // Calculate attractive force from child nodes (below)
                            node.outEdges.forEach(targetId => {
                                const target = nodeMap.get(targetId);
                                // Only consider nodes in different layers (skip same-layer edges)
                                if (target && target.y !== node.y) {
                                    const diff = target.x - node.x;
                                    forceX += diff * forceStrength;
                                }
                            });

                            // Calculate attractive force from parent nodes (above)
                            node.inEdges.forEach(sourceId => {
                                const source = nodeMap.get(sourceId);
                                if (source && source.y !== node.y) {
                                    const diff = source.x - node.x;
                                    forceX += diff * forceStrength;
                                }
                            });

                            // Apply averaged force to prevent wild oscillations
                            const connectedCount = node.outEdges.length + node.inEdges.length;
                            if (connectedCount > 0) {
                                node.x += forceX / connectedCount;
                            }
                        });
                    });
                }
            }
        };

        // --- COMPONENTS ---

        const PropertiesPanel = ({ selection, nodes, edges, onChange }) => {
            if (!selection) return (
                <div className="absolute top-20 right-6 w-64 glass-panel rounded-xl p-6 text-center text-slate-500 text-sm shadow-xl">
                    <div className="mb-2">
                        <Icons.Edit className="w-8 h-8 mx-auto mb-2 opacity-30"/>
                    </div>
                    <p className="font-medium mb-1">No Selection</p>
                    <p className="text-xs">Click a node or link to edit</p>
                </div>
            );

            const { id, type } = selection;
            const item = type === 'node'
                ? nodes.find(n => n.id === id)
                : edges.find(e => e.id === id);

            if (!item) return null;

            return (
                <div className="absolute top-20 right-6 w-72 glass-panel rounded-xl p-4 shadow-2xl z-50 modal-animate border-2 border-blue-500/30" onClick={(e) => e.stopPropagation()}>
                    <div className="flex items-center justify-between mb-4 pb-2 border-b border-slate-700">
                        <span className="text-xs font-bold text-slate-400 uppercase tracking-wider">{type} PROPERTIES</span>
                        <div className="px-2 py-0.5 bg-slate-800 rounded text-[10px] text-slate-500 font-mono">{id}</div>
                    </div>

                    <div className="space-y-4">
                        {type === 'node' && (
                            <>
                                <div>
                                    <label className="block text-xs text-slate-400 mb-1">Label</label>
                                    <input type="text" value={item.label || ''} onChange={(e) => onChange(id, type, 'label', e.target.value)} 
                                        className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-blue-500" />
                                </div>
                                <div>
                                    <label className="block text-xs text-slate-400 mb-1">Sub-Label</label>
                                    <input type="text" value={item.sub || ''} onChange={(e) => onChange(id, type, 'sub', e.target.value)} 
                                        className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-blue-500" />
                                </div>
                                <div>
                                    <label className="block text-xs text-slate-400 mb-1">Style Type</label>
                                    <select value={item.type || 'default'} onChange={(e) => onChange(id, type, 'type', e.target.value)}
                                        className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-blue-500">
                                        <option value="default">Default (Grey)</option>
                                        <option value="primary">Primary (Blue)</option>
                                        <option value="secondary">Secondary (Purple)</option>
                                        <option value="tertiary">Tertiary (Emerald)</option>
                                        <option value="warning">Warning (Amber)</option>
                                        <option value="danger">Danger (Rose)</option>
                                        <option value="ghost">Ghost (Dashed)</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="block text-xs text-slate-400 mb-1">Icon</label>
                                    <select value={item.icon || ''} onChange={(e) => onChange(id, type, 'icon', e.target.value)}
                                        className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-blue-500">
                                        <option value="">None</option>
                                        {Object.keys(Icons).map(k => <option key={k} value={k}>{k}</option>)}
                                    </select>
                                </div>
                            </>
                        )}
                        
                        {type === 'edge' && (
                            <>
                                <div>
                                    <label className="block text-xs text-slate-400 mb-1">Label</label>
                                    <input type="text" value={item.label || ''} onChange={(e) => onChange(id, type, 'label', e.target.value)} 
                                        className="w-full bg-slate-900 border border-slate-700 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-blue-500" />
                                </div>
                                <div className="flex items-center space-x-2 pt-2">
                                    <input type="checkbox" checked={item.dashed || false} onChange={(e) => onChange(id, type, 'dashed', e.target.checked)} id="dashCheck" />
                                    <label htmlFor="dashCheck" className="text-sm text-slate-300">Dashed Line</label>
                                </div>
                                <div className="pt-2 border-t border-slate-700 mt-2">
                                    <p className="text-[10px] text-slate-500 mb-2">RE-LINKING</p>
                                    <div className="grid grid-cols-2 gap-2">
                                        <button onClick={() => onChange(id, type, 'relink-source')} className="px-2 py-1.5 bg-slate-800 hover:bg-slate-700 border border-slate-600 rounded text-xs">Change Source</button>
                                        <button onClick={() => onChange(id, type, 'relink-target')} className="px-2 py-1.5 bg-slate-800 hover:bg-slate-700 border border-slate-600 rounded text-xs">Change Target</button>
                                    </div>
                                    <p className="text-[10px] text-slate-500 mt-1 italic">Click button then click new node</p>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const HelpModal = ({ onClose }) => (
            <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4" onClick={onClose}>
                <div className="bg-slate-900 border border-slate-700 rounded-2xl shadow-2xl max-w-lg w-full overflow-hidden modal-animate" onClick={e => e.stopPropagation()}>
                    <div className="bg-gradient-to-r from-blue-900/40 to-purple-900/40 p-6 border-b border-slate-700 flex justify-between items-center">
                        <div className="flex items-center space-x-3">
                            <div className="p-2 bg-blue-500 rounded-lg text-white"><Icons.HelpCircle className="w-6 h-6" /></div>
                            <h2 className="text-xl font-bold text-white">Visual Editor Guide</h2>
                        </div>
                        <button onClick={onClose} className="text-slate-400 hover:text-white transition-colors"><Icons.X className="w-6 h-6" /></button>
                    </div>
                    <div className="p-6 space-y-4 text-slate-300 text-sm">
                        <div className="grid grid-cols-2 gap-4">
                            <div className="bg-slate-800/50 p-3 rounded-lg border border-slate-700/50">
                                <div className="font-bold text-blue-400 mb-1">Selection</div>
                                <p>Click any node or line to select it. Properties will appear on the right.</p>
                            </div>
                            <div className="bg-slate-800/50 p-3 rounded-lg border border-slate-700/50">
                                <div className="font-bold text-purple-400 mb-1">Add & Link</div>
                                <p>Use the Toolbar to Add Nodes (+) or Switch to Link Mode (Link Icon) to connect them.</p>
                            </div>
                            <div className="bg-slate-800/50 p-3 rounded-lg border border-slate-700/50">
                                <div className="font-bold text-emerald-400 mb-1">Drag to Reconnect</div>
                                <p>Select a line to see draggable handles. Drag the green (source) or blue (target) circle to reconnect to a different node.</p>
                            </div>
                            <div className="bg-slate-800/50 p-3 rounded-lg border border-slate-700/50">
                                <div className="font-bold text-amber-400 mb-1">Persistence</div>
                                <p>Your edits are saved as you switch tabs. Don't refresh the browser!</p>
                            </div>
                        </div>
                        <div className="pt-4 border-t border-slate-800">
                            <div className="font-bold text-slate-200 mb-2">⌨️ Keyboard Shortcuts</div>
                            <div className="grid grid-cols-2 gap-2 text-xs">
                                <div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded">
                                    <span>Delete item</span>
                                    <kbd className="bg-slate-700 px-2 py-0.5 rounded font-mono">Del</kbd>
                                </div>
                                <div className="flex justify-between items-center bg-slate-800/30 px-2 py-1 rounded">
                                    <span>Cancel mode</span>
                                    <kbd className="bg-slate-700 px-2 py-0.5 rounded font-mono">Esc</kbd>
                                </div>
                            </div>
                        </div>
                        <div className="pt-2 text-center">
                            <button onClick={onClose} className="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg font-medium shadow-lg transition-colors">Start Editing</button>
                        </div>
                    </div>
                </div>
            </div>
        );

        // --- MAIN APP COMPONENT ---

        const OrganizationVisualizer = () => {
            const [allData, setAllData] = useState(INITIAL_DATA_SETS);
            const [activeTab, setActiveTab] = useState('1.1');
            const [scale, setScale] = useState(1);
            const [isLocked, setIsLocked] = useState(false);
            const [showHelp, setShowHelp] = useState(true);
            const [selection, setSelection] = useState(null);
            const [isDragging, setIsDragging] = useState(false);
            const [draggedNodeId, setDraggedNodeId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [mode, setMode] = useState('select');
            const [connectSource, setConnectSource] = useState(null);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [isExporting, setIsExporting] = useState(false);
            const [isArranging, setIsArranging] = useState(false);
            const [theme, setTheme] = useState('dark');
            const [showThemeMenu, setShowThemeMenu] = useState(false);
            const [draggedEdge, setDraggedEdge] = useState(null); // { edgeId, end: 'source' | 'target' }
            const [edgePreviewTarget, setEdgePreviewTarget] = useState(null);
            
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const exportRef = useRef(null);

            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    e.preventDefault();
                    e.returnValue = '';
                };
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, []);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    // Delete or Backspace to delete selection
                    if ((e.key === 'Delete' || e.key === 'Backspace') && selection) {
                        e.preventDefault();
                        deleteSelection();
                    }
                    // Escape to cancel modes and clear selection
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        setMode('select');
                        setConnectSource(null);
                        setSelection(null);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selection, mode]);

            const currentNodes = allData[activeTab]?.nodes || [];
            const currentEdges = allData[activeTab]?.edges || [];
            const currentTheme = THEMES[theme];

            // --- EXPORT CALCS ---
            /**
             * Calculates the bounding box for PNG export.
             *
             * Computes the minimum rectangle that contains all nodes, with padding.
             * Used to create a properly-sized export canvas that captures the entire
             * graph without excess whitespace.
             *
             * The calculation:
             * 1. Find the leftmost and rightmost node edges (considering node width)
             * 2. Find the topmost and bottommost node edges (considering node height)
             * 3. Add padding around the bounding box
             *
             * The returned minX/minY values are used to translate node positions
             * during export so the graph is positioned at the top-left of the canvas.
             *
             * @returns {Object} Bounding box with { width, height, minX, minY, padding }
             */
            const exportBounds = useMemo(() => {
                // Default dimensions for empty canvas
                if (currentNodes.length === 0) return { width: 800, height: 600, minX: 0, minY: 0 };
                const padding = 50; // Margin around the exported content
                // Calculate bounding box from all node positions
                const minX = Math.min(...currentNodes.map(n => n.x));
                const maxX = Math.max(...currentNodes.map(n => n.x + (n.width || 180)));
                const minY = Math.min(...currentNodes.map(n => n.y));
                const maxY = Math.max(...currentNodes.map(n => n.y + (n.height || 80)));
                return {
                    width: maxX - minX + (padding * 2),
                    height: maxY - minY + (padding * 2),
                    minX,  // Used to translate nodes to top-left origin
                    minY,  // Used to translate nodes to top-left origin
                    padding
                };
            }, [currentNodes]);

            const updateNode = (id, field, value) => {
                setAllData(prev => ({
                    ...prev,
                    [activeTab]: {
                        ...prev[activeTab],
                        nodes: prev[activeTab].nodes.map(n => n.id === id ? { ...n, [field]: value } : n)
                    }
                }));
            };

            const updateEdge = (id, field, value) => {
                setAllData(prev => ({
                    ...prev,
                    [activeTab]: {
                        ...prev[activeTab],
                        edges: prev[activeTab].edges.map(e => e.id === id ? { ...e, [field]: value } : e)
                    }
                }));
            };

            const addNode = () => {
                const newId = generateId();
                const container = containerRef.current;
                const centerX = (container.scrollLeft + container.clientWidth / 2) / scale - 50;
                const centerY = (container.scrollTop + container.clientHeight / 2) / scale - 50;
                const newNode = { id: newId, x: centerX, y: centerY, type: 'default', label: 'New Node', width: 180, height: 80 };
                setAllData(prev => ({
                    ...prev,
                    [activeTab]: {
                        ...prev[activeTab],
                        nodes: [...prev[activeTab].nodes, newNode]
                    }
                }));
                setSelection({ id: newId, type: 'node' });
            };

            const deleteSelection = () => {
                if (!selection) return;
                const { id, type } = selection;
                if (type === 'node') {
                    setAllData(prev => ({
                        ...prev,
                        [activeTab]: {
                            ...prev[activeTab],
                            nodes: prev[activeTab].nodes.filter(n => n.id !== id),
                            edges: prev[activeTab].edges.filter(e => e.source !== id && e.target !== id)
                        }
                    }));
                } else {
                    setAllData(prev => ({
                        ...prev,
                        [activeTab]: {
                            ...prev[activeTab],
                            edges: prev[activeTab].edges.filter(e => e.id !== id)
                        }
                    }));
                }
                setSelection(null);
            };

            const handlePropertyChange = (id, type, field, value) => {
                if (field === 'relink-source') { setMode('relink-source'); return; }
                if (field === 'relink-target') { setMode('relink-target'); return; }
                if (type === 'node') updateNode(id, field, value);
                else updateEdge(id, field, value);
            };

            const handleMouseDown = (e, nodeId) => {
                if (isLocked) return;
                e.stopPropagation();
                e.preventDefault();
                if (mode === 'connect') { setConnectSource(nodeId); return; }
                if (mode === 'relink-source') {
                    if (selection && selection.type === 'edge') { updateEdge(selection.id, 'source', nodeId); setMode('select'); }
                    return;
                }
                if (mode === 'relink-target') {
                     if (selection && selection.type === 'edge') { updateEdge(selection.id, 'target', nodeId); setMode('select'); }
                    return;
                }
                const node = currentNodes.find(n => n.id === nodeId);
                setSelection({ id: nodeId, type: 'node' });
                setDraggedNodeId(nodeId);
                setDragOffset({ x: e.clientX / scale - node.x, y: e.clientY / scale - node.y });
                setIsDragging(true);
            };

            const handleCanvasMouseMove = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                setMousePos({ x: (e.clientX - rect.left) / scale, y: (e.clientY - rect.top) / scale });

                // Handle edge endpoint dragging
                if (draggedEdge) {
                    const currentMouseX = (e.clientX - rect.left) / scale;
                    const currentMouseY = (e.clientY - rect.top) / scale;

                    // Find node under cursor
                    const hoveredNode = currentNodes.find(node => {
                        const nodeWidth = node.width || 180;
                        const nodeHeight = node.height || 80;
                        return currentMouseX >= node.x && currentMouseX <= node.x + nodeWidth &&
                               currentMouseY >= node.y && currentMouseY <= node.y + nodeHeight;
                    });

                    setEdgePreviewTarget(hoveredNode ? hoveredNode.id : null);
                    return;
                }

                // Handle node dragging
                if (!isDragging || !draggedNodeId) return;
                updateNode(draggedNodeId, 'x', (e.clientX / scale) - dragOffset.x);
                updateNode(draggedNodeId, 'y', (e.clientY / scale) - dragOffset.y);
            };

            const handleMouseUp = (e, nodeId) => {
                // Handle edge endpoint reconnection
                if (draggedEdge && edgePreviewTarget) {
                    const edge = currentEdges.find(e => e.id === draggedEdge.edgeId);
                    if (edge) {
                        // Prevent self-loops
                        const otherEnd = draggedEdge.end === 'source' ? edge.target : edge.source;
                        if (edgePreviewTarget !== otherEnd) {
                            updateEdge(draggedEdge.edgeId, draggedEdge.end, edgePreviewTarget);
                        }
                    }
                    setDraggedEdge(null);
                    setEdgePreviewTarget(null);
                    return;
                }

                // Clear edge drag state if no valid target
                if (draggedEdge) {
                    setDraggedEdge(null);
                    setEdgePreviewTarget(null);
                    return;
                }

                // Handle node connection mode
                if (mode === 'connect' && connectSource && nodeId && connectSource !== nodeId) {
                    const newEdge = { id: generateId(), source: connectSource, target: nodeId, label: 'Link' };
                    setAllData(prev => ({
                        ...prev,
                        [activeTab]: { ...prev[activeTab], edges: [...prev[activeTab].edges, newEdge] }
                    }));
                    setConnectSource(null);
                    setMode('select');
                } else if (mode === 'connect') {
                    setConnectSource(null);
                }

                setIsDragging(false);
                setDraggedNodeId(null);
            };

            const handleEdgeEndpointMouseDown = (e, edgeId, end) => {
                e.stopPropagation();
                e.preventDefault();
                setDraggedEdge({ edgeId, end });
                setSelection({ id: edgeId, type: 'edge' });
            };

            const handleEdgeClick = (e, edgeId) => {
                e.stopPropagation();
                e.preventDefault();
                if (mode === 'select') setSelection({ id: edgeId, type: 'edge' });
            };

            const handleCanvasClick = (e) => {
                // Only clear selection if clicking directly on canvas, not on child elements
                if (e.target === e.currentTarget) {
                    setSelection(null);
                    if (mode === 'connect') {
                        setConnectSource(null);
                    }
                }
            };

            const handleAutoArrange = () => {
                setIsArranging(true);
                setTimeout(() => {
                    const width = containerRef.current ? containerRef.current.clientWidth : 1200;
                    const organized = LayoutEngine.autoArrange(activeTab, currentNodes, currentEdges, width);
                    setAllData(prev => ({ ...prev, [activeTab]: { ...prev[activeTab], nodes: organized } }));
                    setTimeout(() => setIsArranging(false), 500);
                }, 50);
            };

            const handleExport = async () => {
                setIsExporting(true);
                setTimeout(async () => {
                    if (window.html2canvas && exportRef.current) {
                        try {
                            const canvas = await window.html2canvas(exportRef.current, {
                                backgroundColor: '#020617',
                                scale: 3,
                                logging: false
                            });
                            const link = document.createElement('a');
                            link.download = `NJPBS_Visual_${activeTab}.png`;
                            link.href = canvas.toDataURL();
                            link.click();
                        } catch (err) { console.error(err); }
                        setIsExporting(false);
                    }
                }, 100);
            };

            const getIcon = (name) => {
                const Comp = Icons[name];
                return Comp ? <Comp className="w-5 h-5" /> : null;
            };

            /**
             * Generates an SVG path string for drawing curved edges between nodes.
             *
             * Creates a smooth cubic Bézier curve from the center of the source node
             * to the center of the target node. The curve uses vertical control points
             * to create a natural-looking arc that works well for hierarchical layouts.
             *
             * The path uses the SVG path syntax:
             * - M: Move to start point (source node center)
             * - C: Cubic Bézier curve with two control points and endpoint
             *
             * Control points are positioned to create a smooth S-curve:
             * - First control point: Same X as start, Y shifted toward end
             * - Second control point: Same X as end, Y shifted toward start
             *
             * @param {Object} start - Source node with x, y, width, height properties
             * @param {Object} end - Target node with x, y, width, height properties
             * @returns {string} SVG path data string, or empty string if nodes are invalid
             *
             * @example
             * const path = drawPath(
             *   { x: 0, y: 0, width: 180, height: 80 },
             *   { x: 200, y: 200, width: 180, height: 80 }
             * );
             * // Returns: "M 90 40 C 90 90, 290 150, 290 240"
             */
            const drawPath = (start, end) => {
                if(!start || !end) return '';
                // Calculate center points of each node
                const startX = start.x + (start.width || 180) / 2;
                const startY = start.y + (start.height || 80) / 2;
                const endX = end.x + (end.width || 180) / 2;
                const endY = end.y + (end.height || 80) / 2;
                // Control point offset based on vertical distance (creates smooth curves)
                const dist = Math.abs(endY - startY);
                // Cubic Bézier: M(start) C(ctrl1, ctrl2, end)
                return `M ${startX} ${startY} C ${startX} ${startY + dist * 0.5}, ${endX} ${endY - dist * 0.5}, ${endX} ${endY}`;
            };

            return (
                <div className="flex flex-col h-screen overflow-hidden"
                     style={{ backgroundColor: currentTheme.bg, color: currentTheme.text }}
                     onMouseMove={handleCanvasMouseMove}
                     onMouseUp={() => handleMouseUp(null, null)}
                >
                    {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
                    
                    <PropertiesPanel selection={selection} nodes={currentNodes} edges={currentEdges} onChange={handlePropertyChange} />

                    {/* Header */}
                    <header className="flex-none bg-slate-900/90 backdrop-blur border-b border-slate-800 px-6 py-4 flex items-center justify-between z-50">
                        <div className="flex items-center space-x-4">
                            <div className="w-10 h-10 bg-blue-600 rounded-lg flex items-center justify-center font-bold text-white shadow">NJ</div>
                            <div>
                                <h1 className="text-lg font-bold text-white leading-none">Visual Editor</h1>
                                <p className="text-xs text-slate-400 mt-1">Live Persistence Active</p>
                            </div>
                        </div>
                        <div className="bg-slate-950 p-1 rounded-lg border border-slate-800">
                            {['1.1', '1.2', '1.3'].map(tab => (
                                <button key={tab} onClick={() => { setActiveTab(tab); setSelection(null); }}
                                    className={`px-4 py-1.5 rounded-md text-sm font-medium transition-all ${activeTab === tab ? 'bg-slate-800 text-white shadow ring-1 ring-slate-700' : 'text-slate-400 hover:text-white'}`}>
                                    {tab}
                                </button>
                            ))}
                        </div>
                        <div className="flex items-center space-x-2">
                             <div className="h-8 w-px bg-slate-800 mx-2"></div>
                            <button onClick={(e) => { e.stopPropagation(); addNode(); }} className="p-2 bg-emerald-500/10 text-emerald-400 hover:bg-emerald-500/20 rounded-md border border-emerald-500/20 transition-all group relative" title="Add Node">
                                <Icons.Plus className="w-5 h-5"/>
                                <span className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">Add Node</span>
                            </button>
                            <button onClick={(e) => { e.stopPropagation(); setMode(mode === 'connect' ? 'select' : 'connect'); }} className={`p-2 rounded-md border transition-all group relative ${mode === 'connect' ? 'bg-blue-500 text-white border-blue-400 shadow-[0_0_10px_rgba(59,130,246,0.5)]' : 'bg-slate-800 text-slate-400 border-slate-700 hover:text-white'}`} title="Link Mode">
                                <Icons.Link className="w-5 h-5"/>
                                <span className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">Link Mode (L)</span>
                            </button>
                            <button onClick={(e) => { e.stopPropagation(); deleteSelection(); }} disabled={!selection} className={`p-2 rounded-md transition-all group relative ${selection ? 'bg-rose-500/10 text-rose-400 hover:bg-rose-500/20 border border-rose-500/20' : 'text-slate-600 cursor-not-allowed border border-transparent'}`} title="Delete">
                                <Icons.Trash2 className="w-5 h-5"/>
                                <span className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">Delete (Del)</span>
                            </button>
                             <div className="h-8 w-px bg-slate-800 mx-2"></div>
                            <button onClick={() => handleAutoArrange()} className="p-2 text-blue-400 hover:text-white hover:bg-blue-600/20 rounded-md transition-all group relative" title="Auto Arrange">
                                <Icons.Sparkles className="w-5 h-5"/>
                                <span className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">Auto Arrange</span>
                            </button>
                            <button onClick={handleExport} className="p-2 text-slate-400 hover:text-white hover:bg-slate-800 rounded-md transition-all group relative" title="Save PNG">
                                <Icons.Camera className="w-5 h-5"/>
                                <span className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">Export PNG</span>
                            </button>
                            <button onClick={() => setShowHelp(true)} className="p-2 text-slate-400 hover:text-white transition-all group relative" title="Help">
                                <Icons.HelpCircle className="w-5 h-5"/>
                                <span className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none">Help (H)</span>
                            </button>
                             <div className="h-8 w-px bg-slate-800 mx-2"></div>
                            <div className="relative">
                                <button onClick={(e) => { e.stopPropagation(); setShowThemeMenu(!showThemeMenu); }} className="p-2 text-slate-400 hover:text-white transition-all group relative" title="Theme">
                                    <Icons.Palette className="w-5 h-5"/>
                                    <span className="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-50">Theme</span>
                                </button>
                                {showThemeMenu && (
                                    <div className="absolute top-full right-0 mt-2 glass-panel rounded-lg shadow-2xl border border-slate-700 overflow-hidden z-[60] modal-animate min-w-[160px]" onClick={(e) => e.stopPropagation()}>
                                        {Object.keys(THEMES).map(themeKey => (
                                            <button
                                                key={themeKey}
                                                onClick={() => { setTheme(themeKey); setShowThemeMenu(false); }}
                                                className={`w-full px-4 py-2.5 text-left text-sm flex items-center justify-between space-x-3 transition-colors ${theme === themeKey ? 'bg-blue-600 text-white' : 'text-slate-300 hover:bg-slate-800/80'}`}
                                            >
                                                <span>{THEMES[themeKey].name}</span>
                                                {theme === themeKey && <div className="w-2 h-2 bg-white rounded-full"></div>}
                                            </button>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    </header>

                    {/* Zoom Controls */}
                    <div className="absolute bottom-6 right-6 flex flex-col space-y-2 z-30">
                        <button onClick={(e) => { e.stopPropagation(); setScale(Math.min(scale + 0.1, 2)); }} className="p-2 glass-panel rounded-lg text-slate-300 hover:text-white hover:bg-slate-800/90 transition-all shadow-lg" title="Zoom In">
                            <Icons.Plus className="w-5 h-5"/>
                        </button>
                        <div className="px-3 py-1 glass-panel rounded-lg text-xs font-mono text-slate-400 text-center min-w-[60px]">
                            {Math.round(scale * 100)}%
                        </div>
                        <button onClick={(e) => { e.stopPropagation(); setScale(Math.max(scale - 0.1, 0.5)); }} className="p-2 glass-panel rounded-lg text-slate-300 hover:text-white hover:bg-slate-800/90 transition-all shadow-lg" title="Zoom Out">
                            <Icons.Minimize className="w-5 h-5"/>
                        </button>
                        <button onClick={(e) => { e.stopPropagation(); setScale(1); }} className="p-2 glass-panel rounded-lg text-slate-300 hover:text-white hover:bg-slate-800/90 transition-all shadow-lg" title="Reset Zoom">
                            <Icons.Maximize className="w-5 h-5"/>
                        </button>
                    </div>

                    {/* Mode Indicator */}
                    {mode !== 'select' && (
                        <div className="absolute top-24 left-1/2 transform -translate-x-1/2 z-30">
                            <div className="glass-panel rounded-full px-6 py-3 shadow-2xl border-2 border-blue-500/50 modal-animate">
                                <div className="flex items-center space-x-3">
                                    <div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
                                    <span className="text-sm font-semibold text-blue-300">
                                        {mode === 'connect' && 'Link Mode: Click two nodes to connect'}
                                        {mode === 'relink-source' && 'Select New Source Node'}
                                        {mode === 'relink-target' && 'Select New Target Node'}
                                    </span>
                                    <button onClick={(e) => { e.stopPropagation(); setMode('select'); setConnectSource(null); }} className="text-slate-400 hover:text-white ml-2">
                                        <Icons.X className="w-4 h-4"/>
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Auto-Arrange Indicator */}
                    {isArranging && (
                        <div className="absolute top-24 left-1/2 transform -translate-x-1/2 z-30">
                            <div className="glass-panel rounded-full px-6 py-3 shadow-2xl border-2 border-emerald-500/50 modal-animate">
                                <div className="flex items-center space-x-3">
                                    <div className="w-5 h-5 border-2 border-emerald-500 border-t-transparent rounded-full animate-spin"></div>
                                    <span className="text-sm font-semibold text-emerald-300">Organizing layout...</span>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Status Bar */}
                    <div className="absolute bottom-6 left-6 z-30 flex items-center space-x-4">
                        <div className="glass-panel rounded-lg px-4 py-2 shadow-lg">
                            <div className="flex items-center space-x-4 text-xs">
                                <div className="flex items-center space-x-2">
                                    <Icons.Target className="w-4 h-4 text-blue-400"/>
                                    <span className="text-slate-400">Nodes:</span>
                                    <span className="text-white font-semibold">{currentNodes.length}</span>
                                </div>
                                <div className="h-4 w-px bg-slate-700"></div>
                                <div className="flex items-center space-x-2">
                                    <Icons.Link className="w-4 h-4 text-purple-400"/>
                                    <span className="text-slate-400">Links:</span>
                                    <span className="text-white font-semibold">{currentEdges.length}</span>
                                </div>
                                {selection && (
                                    <>
                                        <div className="h-4 w-px bg-slate-700"></div>
                                        <div className="flex items-center space-x-2">
                                            <div className="w-2 h-2 bg-blue-500 rounded-full animate-pulse"></div>
                                            <span className="text-blue-300 font-medium">
                                                {selection.type === 'node'
                                                    ? (currentNodes.find(n => n.id === selection.id)?.label || 'Node')
                                                    : 'Link'} selected
                                            </span>
                                        </div>
                                    </>
                                )}
                            </div>
                        </div>
                    </div>

                    {/* Canvas */}
                    <div ref={containerRef} className="flex-grow overflow-auto relative cursor-grab active:cursor-grabbing custom-scrollbar" style={{ backgroundColor: currentTheme.canvas }} onClick={handleCanvasClick}>
                        <div className="absolute inset-0 pointer-events-none" style={{ opacity: currentTheme.gridOpacity, backgroundImage: `linear-gradient(to right, ${currentTheme.gridColor} 1px, transparent 1px), linear-gradient(to bottom, ${currentTheme.gridColor} 1px, transparent 1px)`, backgroundSize: '40px 40px', transform: `scale(${scale})`, transformOrigin: '0 0' }}/>
                        <div ref={canvasRef} className="relative min-w-[3000px] min-h-[3000px] transform-gpu origin-top-left p-10" style={{ transform: `scale(${scale})` }}>
                            <svg className="absolute top-0 left-0 w-full h-full pointer-events-none overflow-visible z-0">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill={currentTheme.edgeColor} />
                                    </marker>
                                    <marker id="arrowhead-selected" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                                    </marker>
                                </defs>
                                {currentEdges.map(edge => {
                                    const start = currentNodes.find(n => n.id === edge.source);
                                    const end = currentNodes.find(n => n.id === edge.target);
                                    if(!start || !end) return null;

                                    // If this edge is being dragged, use preview target if available
                                    const displayStart = (draggedEdge?.edgeId === edge.id && draggedEdge.end === 'source' && edgePreviewTarget)
                                        ? currentNodes.find(n => n.id === edgePreviewTarget) || start
                                        : start;
                                    const displayEnd = (draggedEdge?.edgeId === edge.id && draggedEdge.end === 'target' && edgePreviewTarget)
                                        ? currentNodes.find(n => n.id === edgePreviewTarget) || end
                                        : end;

                                    // For dragged edge with no target, use mouse position
                                    const isDraggingThisEdge = draggedEdge?.edgeId === edge.id;
                                    let finalEnd = displayEnd;
                                    let finalStart = displayStart;

                                    if (isDraggingThisEdge && !edgePreviewTarget) {
                                        if (draggedEdge.end === 'target') {
                                            finalEnd = { x: mousePos.x - 90, y: mousePos.y - 40, width: 180, height: 80 };
                                        } else {
                                            finalStart = { x: mousePos.x - 90, y: mousePos.y - 40, width: 180, height: 80 };
                                        }
                                    }

                                    const path = drawPath(finalStart, finalEnd);
                                    const isSelected = selection && selection.id === edge.id;

                                    // Calculate endpoint positions for handles
                                    const startX = start.x + (start.width || 180) / 2;
                                    const startY = start.y + (start.height || 80) / 2;
                                    const endX = end.x + (end.width || 180) / 2;
                                    const endY = end.y + (end.height || 80) / 2;

                                    return (
                                        <g key={edge.id} onClick={(e) => handleEdgeClick(e, edge.id)} className="cursor-pointer pointer-events-auto group">
                                            <path d={path} stroke="transparent" strokeWidth="20" fill="none" />
                                            <path d={path} stroke={isDraggingThisEdge ? "#60a5fa" : (isSelected ? "#3b82f6" : currentTheme.edgeColor)} strokeWidth={isSelected ? "4" : "2"} fill="none" markerEnd={isSelected ? "url(#arrowhead-selected)" : "url(#arrowhead)"} strokeDasharray={(edge.dashed || isDraggingThisEdge) ? "5,5" : "none"} className="transition-all" style={{ stroke: isSelected ? "#3b82f6" : undefined }} onMouseEnter={(e) => !isSelected && (e.currentTarget.style.stroke = currentTheme.edgeColorHover)} onMouseLeave={(e) => !isSelected && (e.currentTarget.style.stroke = currentTheme.edgeColor)} />

                                            {/* Draggable endpoint handles - show on hover or when selected */}
                                            {(isSelected || isDraggingThisEdge) && (
                                                <>
                                                    {/* Source handle */}
                                                    <circle
                                                        cx={startX}
                                                        cy={startY}
                                                        r="6"
                                                        fill="#10b981"
                                                        stroke="#fff"
                                                        strokeWidth="2"
                                                        className="cursor-grab active:cursor-grabbing opacity-0 group-hover:opacity-100 transition-opacity"
                                                        style={{ opacity: isDraggingThisEdge && draggedEdge.end === 'source' ? 1 : undefined }}
                                                        onMouseDown={(e) => handleEdgeEndpointMouseDown(e, edge.id, 'source')}
                                                    />
                                                    {/* Target handle */}
                                                    <circle
                                                        cx={endX}
                                                        cy={endY}
                                                        r="6"
                                                        fill="#3b82f6"
                                                        stroke="#fff"
                                                        strokeWidth="2"
                                                        className="cursor-grab active:cursor-grabbing opacity-0 group-hover:opacity-100 transition-opacity"
                                                        style={{ opacity: isDraggingThisEdge && draggedEdge.end === 'target' ? 1 : undefined }}
                                                        onMouseDown={(e) => handleEdgeEndpointMouseDown(e, edge.id, 'target')}
                                                    />
                                                </>
                                            )}

                                            {edge.label && (
                                                <foreignObject x={(start.x + end.x + 180)/2 - 40} y={(start.y + end.y + 80)/2 - 12} width="80" height="24">
                                                    <div className={`text-[10px] px-2 py-0.5 rounded-full text-center whitespace-nowrap shadow-sm border ${isSelected ? 'bg-blue-900 border-blue-500 text-white' : 'bg-slate-900 border-slate-700 text-slate-400'}`}>{edge.label}</div>
                                                </foreignObject>
                                            )}
                                        </g>
                                    );
                                })}
                                {mode === 'connect' && connectSource && (
                                    <path d={drawPath(currentNodes.find(n => n.id === connectSource), { x: mousePos.x - 90, y: mousePos.y - 40, width: 180, height: 80 })} stroke="#3b82f6" strokeWidth="2" strokeDasharray="5,5" fill="none" />
                                )}
                            </svg>
                            {currentNodes.map(node => {
                                const isSelected = selection && selection.id === node.id;
                                const isConnecting = mode === 'connect' || mode.includes('relink');
                                const isSourceNode = connectSource === node.id;
                                const isEdgeTarget = edgePreviewTarget === node.id;
                                const cursorClass = isConnecting || draggedEdge ? 'cursor-pointer' : (isLocked ? 'cursor-default' : 'cursor-move');
                                return (
                                    <div key={node.id} onMouseDown={(e) => handleMouseDown(e, node.id)} onMouseUp={(e) => handleMouseUp(e, node.id)} style={{ transform: `translate(${node.x}px, ${node.y}px)`, width: `${node.width || 180}px` }} className={`absolute z-10 flex flex-col justify-center px-4 py-3 rounded-xl border transition-all select-none group ${cursorClass} ${currentTheme.nodes[node.type] || currentTheme.nodes.default} ${isSelected ? 'ring-4 ring-blue-500 scale-105 shadow-2xl z-50' : 'hover:scale-[1.02] hover:shadow-xl'} ${isConnecting ? 'hover:ring-2 hover:ring-emerald-500' : ''} ${isSourceNode ? 'ring-4 ring-emerald-500 shadow-[0_0_30px_rgba(16,185,129,0.4)]' : ''} ${isEdgeTarget ? 'ring-4 ring-purple-500 shadow-[0_0_30px_rgba(168,85,247,0.5)] scale-105' : ''}`}>
                                        {(mode === 'connect' || mode.includes('relink')) && !isSourceNode && <div className="pulse-dot absolute inset-0 rounded-xl bg-emerald-500/10 pointer-events-none"></div>}
                                        {isSourceNode && <div className="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-emerald-500 text-white text-xs px-2 py-1 rounded whitespace-nowrap shadow-lg">Source Node</div>}
                                        <div className="flex items-center space-x-3 pointer-events-none">
                                            {node.icon && <div className={`p-2 rounded-lg ${node.type === 'primary' ? 'bg-blue-500/20 text-blue-300' : node.type === 'secondary' ? 'bg-purple-500/20 text-purple-300' : 'bg-slate-700/50 text-slate-300'}`}>{getIcon(node.icon)}</div>}
                                            <div><h3 className="font-bold text-sm leading-tight tracking-wide">{node.label}</h3>{node.sub && <p className="text-[10px] opacity-70 mt-0.5 font-medium uppercase tracking-wider">{node.sub}</p>}</div>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* HIDDEN EXPORT LAYER */}
                    {isExporting && (
                        <div ref={exportRef} style={{
                            position: 'fixed', top: '-10000px', left: '-10000px',
                            width: `${exportBounds.width}px`, height: `${exportBounds.height}px`,
                            backgroundColor: currentTheme.canvas, zIndex: -1000
                        }}>
                             <div className="absolute inset-0" style={{ opacity: currentTheme.gridOpacity, backgroundImage: `linear-gradient(to right, ${currentTheme.gridColor} 1px, transparent 1px), linear-gradient(to bottom, ${currentTheme.gridColor} 1px, transparent 1px)`, backgroundSize: '40px 40px' }}/>
                             <svg className="absolute top-0 left-0 w-full h-full overflow-visible">
                                <defs>
                                    <marker id="arrowhead-export" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill={currentTheme.edgeColor} />
                                    </marker>
                                </defs>
                                {currentEdges.map(edge => {
                                    const start = currentNodes.find(n => n.id === edge.source);
                                    const end = currentNodes.find(n => n.id === edge.target);
                                    if(!start || !end) return null;
                                    // Shift coordinates based on bounding box
                                    const shiftedStart = { ...start, x: start.x - exportBounds.minX + exportBounds.padding, y: start.y - exportBounds.minY + exportBounds.padding };
                                    const shiftedEnd = { ...end, x: end.x - exportBounds.minX + exportBounds.padding, y: end.y - exportBounds.minY + exportBounds.padding };
                                    const path = drawPath(shiftedStart, shiftedEnd);
                                    return (
                                        <g key={'export-' + edge.id}>
                                            <path d={path} stroke={currentTheme.edgeColor} strokeWidth="2" fill="none" markerEnd="url(#arrowhead-export)" strokeDasharray={edge.dashed ? "5,5" : "none"} />
                                            {edge.label && (
                                                <foreignObject x={(shiftedStart.x + shiftedEnd.x + 180)/2 - 40} y={(shiftedStart.y + shiftedEnd.y + 80)/2 - 12} width="80" height="24">
                                                    <div className="bg-slate-900 border border-slate-700 text-[10px] text-slate-400 px-2 py-0.5 rounded-full text-center whitespace-nowrap shadow-sm">{edge.label}</div>
                                                </foreignObject>
                                            )}
                                        </g>
                                    );
                                })}
                            </svg>
                            {currentNodes.map(node => (
                                <div key={'export-' + node.id} style={{
                                    position: 'absolute',
                                    left: `${node.x - exportBounds.minX + exportBounds.padding}px`,
                                    top: `${node.y - exportBounds.minY + exportBounds.padding}px`,
                                    width: `${node.width || 180}px`
                                }} className={`flex flex-col justify-center px-4 py-3 rounded-xl border ${currentTheme.nodes[node.type] || currentTheme.nodes.default}`}>
                                    <div className="flex items-center space-x-3">
                                        {node.icon && <div className={`p-2 rounded-lg ${node.type === 'primary' ? 'bg-blue-500/20 text-blue-300' : node.type === 'secondary' ? 'bg-purple-500/20 text-purple-300' : 'bg-slate-700/50 text-slate-300'}`}>{getIcon(node.icon)}</div>}
                                        <div><h3 className="font-bold text-sm leading-tight tracking-wide">{node.label}</h3>{node.sub && <p className="text-[10px] opacity-70 mt-0.5 font-medium uppercase tracking-wider">{node.sub}</p>}</div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OrganizationVisualizer />);
    </script>
</body>
</html>
